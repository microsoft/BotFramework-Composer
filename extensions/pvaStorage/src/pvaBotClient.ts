// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import { basename, extname, join, posix, relative } from 'path';

import { ensureFile, pathExists, readFile, unlink, writeFile } from 'fs-extra';
import fetch from 'node-fetch';
import globby from 'globby';

import {
  BotComponentResponse,
  BotComponentUpsertRequest,
  BotProjectMetadata,
  ComponentInfo,
  ObiFileModification,
  PVABotModel,
  PVAMetadata,
} from './types';
import { PVABotsCache } from './pvaBotsCache';
import { logger } from './logger';
import { parseIntentsFromLuFile, getLuFileContentForIntent } from './luHelpers';

const getMinimalRootDialogContent = (botName: string) =>
  JSON.stringify({
    $kind: 'Microsoft.AdaptiveDialog',
    $designer: {
      name: botName || '', // should probably throw if botName is empty
      description: '',
      id: '', // will be generated by Composer
    },
    autoEndDialog: true,
    defaultResultProperty: 'dialog.result',
    triggers: [],
    recognizer: {
      $kind: 'Microsoft.VirtualAgents.Recognizer',
      intents: [],
    },
    generator: `${botName}.lg`,
    id: botName || '',
  });

// converts all paths to "this/is/some/path" format which is understood by PVA's backend
function normalizePath(path: string) {
  return path.replace(/\\/g, '/');
}

export class PVABotClient {
  private botModel: PVABotModel;
  private metadata: BotProjectMetadata;
  private projectPath = '';
  private projectId: string | undefined;
  private electronContext: any;
  private locale = 'en-us'; // TODO: eventually needs to be dynamic

  constructor(id: string, metadata: BotProjectMetadata) {
    this.projectId = id;
    this.metadata = metadata;
    if (!this.metadata.additionalInfo) {
      throw new Error('Attempted to instantiate a PVABotClient without PVA Metadata.');
    }
  }

  /**
   * @param writeFiles Will write all the downloaded content files to disk
   */
  private async fetchBotAndCreateContentMap(writeFiles?: boolean) {
    const pvaMetadata = this.metadata.additionalInfo as PVAMetadata;
    const token = process.env.PVA_DEMO_TOKEN; // TODO: will need to replace this with actual auth
    const url = `${pvaMetadata.baseUrl}api/botauthoring/v1/environments/${pvaMetadata.envId}/bots/${pvaMetadata.botId}/content/botcomponents?includeObiFiles=true`;
    const res = await fetch(url, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json',
        'X-CCI-BotId': pvaMetadata.botId,
        'X-CCI-TenantId': pvaMetadata.tenantId,
      },
      // TODO: why do we ever want to send the snapshot? we only want the most recent list of assets
      body: JSON.stringify({ componentDeltaToken: '' /* this.botModel?.mostRecentContentSnapshot || ''*/ }),
    });
    if (res.status === 200) {
      const data: BotComponentResponse = await res.json();

      this.botModel.mostRecentContentSnapshot = data.contentSnapshot;

      // construct the content map
      for (const change of data.obiFileChanges) {
        if (change.isDeleted) {
          // TODO: we will eventually need to be able to read a .trigger from PVA and alter
          // the main .dialog and .lu files accordingly (reverse of the splitting logic)
          if (writeFiles && extname(change.path) !== '.trigger') {
            const filePath = join(this.projectPath, change.path);
            await unlink(filePath);
          }
          delete this.botModel.obiContentMap[change.path];
        } else {
          this.botModel.obiContentMap[change.path] = change.componentInfo;
          // TODO: we will eventually need to be able to read a .trigger from PVA and alter
          // the main .dialog and .lu files accordingly (reverse of the splitting logic)
          if (writeFiles && extname(change.path) !== '.trigger') {
            const filePath = join(this.projectPath, change.path);
            logger.log(`Writing ${filePath}...`);
            await ensureFile(filePath);
            await writeFile(filePath, change.fileContent);
            logger.log(`${filePath} successfully written!`);
          }
        }
      }
      this.updateBotCache();
      await this.ensureRootDialog();
    } else {
      let error: any = await res.text();
      try {
        error = JSON.parse(error);
      } catch (e) {
        console.error('Error while trying to parse error JSON: ', e);
      } finally {
        console.error(error);
      }
    }
  }

  public async initialize(electronContext: any, botDir: string) {
    // TODO: should electronContext be passed into the constructor?
    this.electronContext = electronContext;
    this.projectPath = normalizePath(botDir);
    // try to get the bot from the cache
    const cachedBot = PVABotsCache[this.projectId];
    if (cachedBot) {
      logger.log(`${this.projectId} already in the PVA cache. Using cached info.`);
      this.botModel = cachedBot;
    } else {
      // go download the bot and construct the content map
      this.initializeBotModel();
      logger.log(`${this.projectId} is not in the PVA cache. Downloading the bot and building content map.`);
      await this.fetchBotAndCreateContentMap(true);
    }
  }

  public trackWrite(path, content) {
    const normalizedPath = normalizePath(path);

    // ignore any changes to the root .lu file or .lg file
    if (
      normalizedPath === this.rootDialogPath ||
      normalizedPath === this.rootDialogLgPath ||
      normalizedPath === this.rootDialogLuPath
    ) {
      logger.log(`Ignoring changes to the root dialog files: ${normalizedPath}`);
      return;
    } else {
      const pvaObiPath = this.convertToPVARelativePath(normalizedPath);
      this.botModel.trackedUpdates[pvaObiPath] = {
        content,
        isDelete: false,
      };
      this.updateBotCache();
    }
  }

  public trackDelete(path) {
    const normalizedPath = normalizePath(path);

    // ignore any changes to the root .lu file or .lg file
    if (
      normalizedPath === this.rootDialogPath ||
      normalizedPath === this.rootDialogLgPath ||
      normalizedPath === this.rootDialogLuPath
    ) {
      logger.log(`Ignoring deletes to the root dialog files: ${normalizedPath}`);
      return;
    } else {
      const pvaObiPath = this.convertToPVARelativePath(normalizedPath);
      this.botModel.trackedUpdates[pvaObiPath] = {
        isDelete: true,
      };
      this.updateBotCache();
    }
  }

  public async saveToPVA() {
    // slice up the root dialog into triggers
    await this.trackRootDialogChanges();

    // check to see if there were any tracked changes
    const changedPaths = Object.keys(this.botModel.trackedUpdates).filter((changedPath) => {
      // only push up changes to .dialog, .lg, and .lu files -- PVA will throw an error for other types
      return !!changedPath && /\.(dialog|lg|lu|trigger)$/.test(changedPath);
    });

    if (changedPaths.length) {
      // construct the request
      const obiFileChanges: ObiFileModification[] = [];
      for (const obiPath of changedPaths) {
        // fill out the component info for the asset if available (newly created assets will not yet have any component info)
        const componentInfo = this.botModel.obiContentMap[obiPath] || ({} as ComponentInfo);
        const modification: ObiFileModification = {
          componentInfo,
          fileContent: this.botModel.trackedUpdates[obiPath].content || '',
          isDeleted: this.botModel.trackedUpdates[obiPath].isDelete,
          path: obiPath,
        };
        obiFileChanges.push(modification);
      }
      const request: BotComponentUpsertRequest = {
        changes: [], // to satisfy existing API shape
        obiFileChanges,
      };
      const pvaMetadata = this.metadata.additionalInfo as PVAMetadata;

      const token = process.env.PVA_DEMO_TOKEN; // TODO: will need to replace this with actual auth
      const url = `${pvaMetadata.baseUrl}api/botauthoring/v1/environments/${pvaMetadata.envId}/bots/${pvaMetadata.botId}/content/botcomponents`;
      const res = await fetch(url, {
        method: 'PUT',
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
          'X-CCI-BotId': pvaMetadata.botId,
          'X-CCI-TenantId': pvaMetadata.tenantId,
        },
        body: JSON.stringify(request),
      });
      if (res.status >= 200 && res.status < 300) {
        // get an updated list of the bot's assets from PVA and rebuild the content map
        await this.fetchBotAndCreateContentMap(false);
        this.botModel.trackedUpdates = {};
        this.updateBotCache();
      } else {
        let error: any = await res.text();
        try {
          error = JSON.parse(error);
          if (error?.ErrorCode === 4104) {
            // content is out of sync -- go get newest content
            await this.fetchBotAndCreateContentMap(false);
          }
        } catch (e) {
          console.error('Error while trying to parse error JSON: ', e);
        } finally {
          console.error(error);
        }
      }
    }
    // no-op if no changes
  }

  private updateBotCache() {
    if (this.projectId) {
      PVABotsCache[this.projectId] = { ...this.botModel };
    }
  }

  private initializeBotModel() {
    this.botModel = {
      obiContentMap: {},
      mostRecentContentSnapshot: '',
      pvaMetadata: this.metadata.additionalInfo as PVAMetadata,
      trackedUpdates: {},
    };
    this.updateBotCache();
  }

  private async ensureRootDialog() {
    const rootDialogExists = await pathExists(this.rootDialogPath);

    // write the root dialog, lg, and lu files for the first time
    if (!rootDialogExists) {
      // delete the placeholder root dialog that satisfies the "isBotFolder()" call
      const existingRootDialogPaths = await globby(posix.join(this.projectPath, '*.dialog'));
      logger.log('Found paths: ', existingRootDialogPaths);
      for (const existingPath of existingRootDialogPaths) {
        await unlink(existingPath);
        logger.log('deleted ', existingPath);
      }

      const rootDialogContent = getMinimalRootDialogContent(this.botName);
      await writeFile(this.rootDialogPath, rootDialogContent); // TODO: need to enforce utf-8?
      logger.log(`Wrote real root dialog file at: ${this.rootDialogPath}`);

      // create the corresponding lu and lg files
      await ensureFile(this.rootDialogLgPath);
      logger.log(`Created root LG file at ${this.rootDialogLgPath}`);

      await ensureFile(this.rootDialogLuPath);
      logger.log(`Created root LU file at ${this.rootDialogLuPath}`);
    }
  }

  private async trackRootDialogChanges() {
    try {
      // parse the root dialog's LU file for any intents and their utterances
      const intents = await parseIntentsFromLuFile(this.rootDialogLuPath);

      // create a trigger file OBI entry for every trigger in the root dialog
      const mainDialogContent = await readFile(this.rootDialogPath, { encoding: 'utf-8' });
      const mainDialogJson = JSON.parse(mainDialogContent);
      const triggers = mainDialogJson.triggers;
      for (const trigger of triggers) {
        const triggerId = trigger.$designer.id;
        const triggerPath = `triggers/${triggerId}/${triggerId}.trigger`;
        const triggerContent = JSON.stringify(trigger);
        // track the trigger file
        this.botModel.trackedUpdates[triggerPath] = {
          content: triggerContent,
          isDelete: false,
        };

        // if the trigger is an OnIntent trigger, we need to generate a .lu file for it based on its intent
        // as defined in the root dialog's lu file
        if (trigger.$kind === 'Microsoft.OnIntent') {
          const triggerIntent = trigger.intent;
          if (intents[triggerIntent]) {
            const triggerLuPath = `triggers/${triggerId}/language-understanding/${this.locale}/${triggerId}.${this.locale}.lu`;
            const triggerLuContent = await getLuFileContentForIntent(
              triggerLuPath,
              triggerIntent,
              intents[triggerIntent]
            );
            // track the trigger lu file
            this.botModel.trackedUpdates[triggerLuPath] = {
              content: triggerLuContent,
              isDelete: false,
            };
          }
        }
        this.updateBotCache();
      }
    } catch (e) {
      console.error('Error trying to track root dialog changes: ', e);
    }
  }

  // converts an absolute on-disk path to a path relative to the PVA bot (the root is the bot folder)
  // Ex: "C:\\Users\\user123\\Bots\\MyBot\\dialogs\\sendDialog\\sendDialog.dialog" -> "dialogs/sendDialog/sendDialog.dialog"
  private convertToPVARelativePath(absolutePath: string) {
    // the trigger paths do not need to be converted to the PVA format because
    // they are already in that format
    if (absolutePath.startsWith('triggers')) {
      return absolutePath;
    }
    return normalizePath(relative(this.projectPath, absolutePath));
  }

  private get botName(): string {
    return basename(this.projectPath);
  }

  private get rootDialogPath(): string {
    return join(this.projectPath, `${this.botName}.dialog`);
  }

  private get rootDialogLgPath(): string {
    return join(this.projectPath, 'language-generation', this.locale, `${this.botName}.${this.locale}.lg`);
  }

  private get rootDialogLuPath(): string {
    return join(this.projectPath, 'language-understanding', this.locale, `${this.botName}.${this.locale}.lu`);
  }
}
