// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import { basename, join, normalize, relative, resolve } from 'path';

import { ensureFile, pathExists, readFile, unlink, writeFile } from 'fs-extra';
import fetch from 'node-fetch';

import {
  BotComponentResponse,
  BotComponentUpsertRequest,
  BotProjectMetadata,
  ComponentInfo,
  ObiFileModification,
  PVABotModel,
  PVAMetadata,
} from './types';
import { PVABotsCache } from './pvaBotsCache';
import { logger } from './logger';
import { parseIntentsFromLuFile, getLuFileContentForIntent } from './luHelpers';

// TODO: make this dynamic
const HARDCODED_TEST_DIR = resolve('C:\\Users\\tonya\\Desktop\\Git Projects\\test\\PULLED-FROM-PVA');
const PVA_TEST_APP_ID = 'a522f059-bb65-47c0-8934-7db6e5286414';

const getMinimalRootDialogContent = (botName: string) =>
  JSON.stringify({
    $kind: 'Microsoft.AdaptiveDialog',
    $designer: {
      name: botName || '', // should probably throw if botName is empty
      description: '',
      id: '', // will be generated by Composer
    },
    autoEndDialog: true,
    defaultResultProperty: 'dialog.result',
    triggers: [],
    recognizer: {
      $kind: 'Microsoft.VirtualAgents.Recognizer',
      intents: [],
    },
    generator: `${botName}.lg`,
    id: botName || '',
  });

// converts all paths to "this/is/some/path" format which is understood by PVA's backend
function normalizePath(path: string) {
  return normalize(path).replace(/\\/g, '/');
}

export class PVABotClient {
  private botModel: PVABotModel;
  private metadata: BotProjectMetadata;
  private projectPath = '';
  private projectId: string | undefined;
  private electronContext: any;

  constructor(id: string, metadata: BotProjectMetadata) {
    this.projectId = id;
    this.metadata = metadata;
    if (!this.metadata.additionalInfo) {
      throw new Error('Attempted to instantiate a PVABotClient without PVA Metadata.');
    }
  }

  /**
   * @param writeFiles Will write all the downloaded content files to disk
   */
  private async fetchBotAndCreateContentMap(writeFiles?: boolean) {
    if (!this.electronContext) {
      console.log('NO ELECTRON CONTEXT DETECTED');
      return;
    }

    const pvaMetadata = this.metadata.additionalInfo as PVAMetadata;
    let token = process.env.PVA_DEMO_TOKEN;
    if (!token) {
      token = await this.electronContext.getAccessToken({
        targetResource: PVA_TEST_APP_ID,
      });
    }
    const url = `${pvaMetadata.baseUrl}api/botauthoring/v1/environments/${pvaMetadata.envId}/bots/${pvaMetadata.botId}/content/botcomponents?includeObiFiles=true`;
    const res = await fetch(url, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json',
        'X-CCI-BotId': pvaMetadata.botId,
        'X-CCI-TenantId': pvaMetadata.tenantId,
      },
      body: JSON.stringify({ componentDeltaToken: this.botModel?.mostRecentContentSnapshot || '' }),
    });
    if (res.status === 200) {
      const data: BotComponentResponse = await res.json();

      this.botModel.mostRecentContentSnapshot = data.contentSnapshot;

      // construct the content map
      for (const change of data.obiFileChanges) {
        if (change.isDeleted) {
          if (writeFiles) {
            const filePath = join(this.projectPath, change.path);
            await unlink(filePath);
          }
          delete this.botModel.obiContentMap[change.path];
        } else {
          this.botModel.obiContentMap[change.path] = change.componentInfo;
          if (writeFiles) {
            const filePath = join(this.projectPath, change.path);
            console.log(`Writing ${filePath}...`);
            await ensureFile(filePath);
            await writeFile(filePath, change.fileContent);
            console.log(`${filePath} successfully written!`);
          }
        }
      }
      this.botModel.trackedUpdates = {};
      this.updateBotCache();
      await this.ensureRootDialog();
    } else {
      const error = await res.text();
      console.error(error);
    }
  }

  public async initialize(electronContext: any) {
    // TODO: should electronContext be passed into the constructor?
    this.electronContext = electronContext;
    this.projectPath = normalizePath(HARDCODED_TEST_DIR);
    // try to get the bot from the cache
    const cachedBot = PVABotsCache[this.projectId];
    if (cachedBot) {
      logger.log(`${this.projectId} already in the PVA cache. Using cached info.`);
      this.botModel = cachedBot;
    } else {
      // go download the bot and construct the content map
      this.initializeBotModel();
      logger.log(`${this.projectId} is not in the PVA cache. Downloading the bot and building content map.`);
      await this.fetchBotAndCreateContentMap(true);
    }
  }

  public trackWrite(path, content) {
    const normalizedPath = normalizePath(path);
    const locale = 'en-us'; // TODO: eventually needs to be dynamic

    // ignore any changes to the root .lu file or .lg file
    if (
      normalizedPath === this.rootDialogPath ||
      normalizedPath ===
        normalizePath(join(this.projectPath, 'language-understanding', locale, `${this.botName}.${locale}.lu`)) ||
      normalizedPath ===
        normalizePath(join(this.projectPath, 'language-generation', locale, `${this.botName}.${locale}.lg`))
    ) {
      logger.log(`Ignoring changes to the root dialog files: ${normalizedPath}`);
      return;
    } else {
      this.botModel.trackedUpdates[normalizedPath] = {
        content,
        isDelete: false,
      };
      this.updateBotCache();
    }
  }

  public trackDelete(path) {
    const normalizedPath = normalizePath(path);
    this.botModel.trackedUpdates[normalizedPath] = {
      isDelete: true,
    };
    this.updateBotCache();
  }

  public async saveToPVA() {
    // slice up the root dialog into triggers
    await this.trackRootDialogChanges();

    // check to see if there were any tracked changes
    const changedPaths = Object.keys(this.botModel.trackedUpdates).filter((changedPath) => {
      // only push up changes to .dialog, .lg, and .lu files -- PVA will throw an error for other types
      return !!changedPath && /\.(dialog|lg|lu|trigger)$/.test(changedPath);
    });
    if (changedPaths.length) {
      // construct the request
      const obiFileChanges: ObiFileModification[] = [];
      for (const obiPath of changedPaths) {
        // fill out the component info for the asset if available (newly created assets will not yet have any component info)
        const componentInfo = this.botModel.obiContentMap[obiPath] || ({} as ComponentInfo);
        const modification: ObiFileModification = {
          componentInfo,
          fileContent: this.botModel.trackedUpdates[obiPath].content || '',
          isDeleted: this.botModel.trackedUpdates[obiPath].isDelete,
          path: this.convertToPVARelativePath(obiPath),
        };
        obiFileChanges.push(modification);
      }
      const request: BotComponentUpsertRequest = {
        changes: [], // to satisfy existing API shape
        obiFileChanges,
      };
      const pvaMetadata = this.metadata.additionalInfo as PVAMetadata;

      let token = process.env.PVA_DEMO_TOKEN;
      if (!token) {
        token = await this.electronContext.getAccessToken({
          targetResource: PVA_TEST_APP_ID,
        });
      }
      const url = `${pvaMetadata.baseUrl}api/botauthoring/v1/environments/${pvaMetadata.envId}/bots/${pvaMetadata.botId}/content/botcomponents`;
      const res = await fetch(url, {
        method: 'PUT',
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
          'X-CCI-BotId': pvaMetadata.botId,
          'X-CCI-TenantId': pvaMetadata.tenantId,
        },
        body: JSON.stringify(request),
      });
      if (res.status === 200) {
        // get an updated list of the bot's assets from PVA and rebuild the content map
        await this.fetchBotAndCreateContentMap(false);
      } else {
        const error = await res.text();
        console.error(error);
      }
    }
    // no-op if no changes
  }

  private updateBotCache() {
    if (this.projectId) {
      PVABotsCache[this.projectId] = { ...this.botModel };
    }
  }

  private initializeBotModel() {
    this.botModel = {
      obiContentMap: {},
      mostRecentContentSnapshot: '',
      pvaMetadata: this.metadata.additionalInfo as PVAMetadata,
      trackedUpdates: {},
    };
    this.updateBotCache();
  }

  private async ensureRootDialog() {
    const botName = basename(this.projectPath);
    const rootDialogName = `${botName}.dialog`;
    const rootDialogPath = join(this.projectPath, rootDialogName);
    const rootDialogExists = await pathExists(rootDialogPath);

    // write the root dialog, lg, and lu files for the first time
    if (!rootDialogExists) {
      const rootDialogContent = getMinimalRootDialogContent(botName);
      await writeFile(rootDialogPath, rootDialogContent); // TODO: need to enforce utf-8?
      //await unlink(tempRootDialogPath);
      logger.log(`Got rid of temp root dialog and wrote real dialog file at: ${rootDialogPath}`);

      // create the corresponding lu and lg files
      const locale = 'en-us'; // TODO: should eventually be dynamic
      const rootLgPath = join(this.projectPath, 'language-generation', locale, `${botName}.${locale}.lg`);
      await ensureFile(rootLgPath);
      logger.log(`Created root LG file at ${rootLgPath}`);

      const rootLuPath = join(this.projectPath, 'language-understanding', locale, `${botName}.${locale}.lu`);
      await ensureFile(rootLuPath);
      logger.log(`Created root LU file at ${rootLuPath}`);
    }
  }

  private async trackRootDialogChanges() {
    try {
      const botName = basename(this.projectPath);
      const locale = 'en-us'; // TODO: should eventually be dynamic

      // parse the root dialog's LU file for any intents and their utterances
      const rootDialogLuFilePath = join(
        this.projectPath,
        'language-understanding',
        'en-us' /* <-- this will eventually have to be dynamic */,
        `${botName}.en-us.lu`
      );
      const intents = await parseIntentsFromLuFile(rootDialogLuFilePath);

      // create a trigger file OBI entry for every trigger in the root dialog
      const mainDialogContent = await readFile(this.rootDialogPath, { encoding: 'utf-8' });
      const mainDialogJson = JSON.parse(mainDialogContent);
      const triggers = mainDialogJson.triggers;
      for (const trigger of triggers) {
        const triggerId = trigger.$designer.id;
        const triggerPath = `triggers/${triggerId}/${triggerId}.trigger`;
        const triggerContent = JSON.stringify(trigger);
        // track the trigger file
        this.botModel.trackedUpdates[triggerPath] = {
          content: triggerContent,
          isDelete: false,
        };

        // if the trigger is an OnIntent trigger, we need to generate a .lu file for it based on its intent
        // as defined in the root dialog's lu file
        if (trigger.$kind === 'Microsoft.OnIntent') {
          const triggerIntent = trigger.intent;
          if (intents[triggerIntent]) {
            const triggerLuPath = `triggers/${triggerId}/language-understanding/${locale}/${triggerId}.${locale}.lu`;
            const triggerLuContent = await getLuFileContentForIntent(
              triggerLuPath,
              triggerIntent,
              intents[triggerIntent]
            );
            // track the trigger lu file
            this.botModel.trackedUpdates[triggerLuPath] = {
              content: triggerLuContent,
              isDelete: false,
            };
          }
        }
        this.updateBotCache();
      }
    } catch (e) {
      console.error('Error trying to track root dialog changes: ', e);
    }
  }

  // converts an absolute on-disk path to a path relative to the PVA bot
  private convertToPVARelativePath(absolutePath: string) {
    // the trigger paths do not need to be converted to the PVA format because
    // they are already in that format
    if (absolutePath.startsWith('triggers')) {
      return absolutePath;
    }
    return relative(this.projectPath, absolutePath);
  }

  private get botName(): string {
    return basename(this.projectPath);
  }

  private get rootDialogPath(): string {
    return normalizePath(join(this.projectPath, `${this.botName}.dialog`));
  }
}
